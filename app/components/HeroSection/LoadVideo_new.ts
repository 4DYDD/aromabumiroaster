import { useVideoStore } from "../../store/videoStore";

interface VideoLoadOptions {
  videoElement: HTMLVideoElement;
  playbackRate?: number;
  downloadThreshold?: number; // Percentage (0-100)
}

/**
 * COMPLETELY REWRITTEN: Simple and direct video loading with aggressive debugging
 * Handles complete video loading with real-time progress tracking
 */
export const handleVideoLoading = async ({
  videoElement,
  playbackRate = 1.3,
  downloadThreshold = 95,
}: VideoLoadOptions): Promise<void> => {
  console.log("=== STARTING VIDEO LOADING PROCESS ===");
  console.log("üé¨ handleVideoLoading function started");
  console.log("üìä Video element:", videoElement);
  console.log("üìä Video src:", videoElement.src);
  console.log("üìä Video duration:", videoElement.duration);
  console.log("üìä Video readyState:", videoElement.readyState);
  console.log("üìä Video buffered.length:", videoElement.buffered.length);

  // Get store functions with extensive logging
  try {
    const store = useVideoStore.getState();
    console.log("üìä Store obtained:", store);

    const { setDownloadProgress, setLoaded, setPlaying, setError } = store;
    console.log("üìä Store functions:", {
      setDownloadProgress: typeof setDownloadProgress,
      setLoaded: typeof setLoaded,
      setPlaying: typeof setPlaying,
      setError: typeof setError,
    });

    // STEP 1: Reset states with immediate verification
    console.log("=== STEP 1: RESETTING STATES ===");

    console.log("üîÑ Calling setDownloadProgress(0)...");
    setDownloadProgress(0);
    console.log("‚úÖ setDownloadProgress(0) completed");

    console.log("üîÑ Calling setLoaded(false)...");
    setLoaded(false);
    console.log("‚úÖ setLoaded(false) completed");

    console.log("üîÑ Calling setPlaying(false)...");
    setPlaying(false);
    console.log("‚úÖ setPlaying(false) completed");

    console.log("üîÑ Calling setError(null)...");
    setError(null);
    console.log("‚úÖ setError(null) completed");

    // STEP 2: Check current buffered state
    console.log("=== STEP 2: CHECKING BUFFERED STATE ===");
    const buffered = videoElement.buffered;
    console.log("üìä Buffered ranges:", buffered.length);

    if (buffered.length > 0) {
      for (let i = 0; i < buffered.length; i++) {
        console.log(
          `üìä Buffered range ${i}: ${buffered.start(i)} - ${buffered.end(i)}`
        );
      }

      const downloadedSeconds = buffered.end(buffered.length - 1);
      const totalSeconds = videoElement.duration;
      const initialProgress = (downloadedSeconds / totalSeconds) * 100;

      console.log(
        `üìä Downloaded: ${downloadedSeconds}/${totalSeconds} seconds`
      );
      console.log(`üìä Initial progress: ${initialProgress.toFixed(1)}%`);

      if (initialProgress >= downloadThreshold) {
        console.log("=== CACHED VIDEO DETECTED ===");
        console.log("‚úÖ Video already cached and ready!");

        console.log("üîÑ Setting final progress to 100%...");
        setDownloadProgress(100);
        console.log("‚úÖ setDownloadProgress(100) completed for cached video");

        console.log("üîÑ Setting playback rate...");
        videoElement.playbackRate = playbackRate;
        console.log("‚úÖ Playback rate set to:", playbackRate);

        console.log("üîÑ Starting video playback...");
        await videoElement.play();
        console.log("‚úÖ Video playback started");

        console.log("üîÑ Setting loaded state...");
        setLoaded(true);
        setPlaying(true);
        console.log("‚úÖ States updated - loading complete!");

        return;
      } else {
        console.log(
          "üìä Partial buffer detected, starting progress tracking..."
        );
        console.log("üîÑ Setting initial progress...");
        setDownloadProgress(Math.round(initialProgress));
        console.log(
          `‚úÖ Initial progress set to: ${Math.round(initialProgress)}%`
        );
      }
    } else {
      console.log("‚ö†Ô∏è No buffered data found, will track from 0%");
    }

    // STEP 3: Start aggressive progress tracking
    console.log("=== STEP 3: STARTING PROGRESS TRACKING ===");
    let progressUpdateCount = 0;
    let isCompleted = false;

    const progressTracker = setInterval(() => {
      if (isCompleted) {
        console.log(
          "üõë Progress tracking already completed, clearing interval"
        );
        clearInterval(progressTracker);
        return;
      }

      progressUpdateCount++;
      console.log(`=== PROGRESS CHECK #${progressUpdateCount} ===`);

      try {
        const currentBuffered = videoElement.buffered;
        console.log("üîç Current buffered.length:", currentBuffered.length);
        console.log("üîç Current duration:", videoElement.duration);
        console.log("üîç Current readyState:", videoElement.readyState);
        console.log("üîç Current networkState:", videoElement.networkState);

        if (
          currentBuffered.length > 0 &&
          !isNaN(videoElement.duration) &&
          videoElement.duration > 0
        ) {
          const currentDownloaded = currentBuffered.end(
            currentBuffered.length - 1
          );
          const currentTotal = videoElement.duration;
          const currentProgress = Math.min(
            (currentDownloaded / currentTotal) * 100,
            100
          );

          console.log(
            `üì• PROGRESS: ${currentDownloaded.toFixed(
              2
            )}/${currentTotal.toFixed(2)}s = ${currentProgress.toFixed(1)}%`
          );

          console.log(
            `üîÑ Updating progress to ${Math.round(currentProgress)}%...`
          );
          setDownloadProgress(Math.round(currentProgress));
          console.log(
            `‚úÖ setDownloadProgress(${Math.round(currentProgress)}) completed`
          );

          // Check if threshold reached
          if (currentProgress >= downloadThreshold) {
            console.log("=== DOWNLOAD THRESHOLD REACHED ===");
            console.log(
              `üéØ Threshold ${downloadThreshold}% reached with ${currentProgress.toFixed(
                1
              )}%`
            );

            isCompleted = true;
            clearInterval(progressTracker);

            // Complete the loading process
            setTimeout(async () => {
              try {
                console.log("üîÑ Finalizing video loading...");
                setDownloadProgress(100);
                console.log("‚úÖ Final progress set to 100%");

                videoElement.playbackRate = playbackRate;
                console.log("‚úÖ Playback rate set");

                await videoElement.play();
                console.log("‚úÖ Video playback started");

                setLoaded(true);
                setPlaying(true);
                console.log("‚úÖ All states updated - LOADING COMPLETE!");
              } catch (playError) {
                console.error("‚ùå Playback error:", playError);
                setLoaded(true); // Still mark as loaded
                setError("Auto-play prevented");
              }
            }, 100);
            return;
          }
        } else {
          console.log("‚ö†Ô∏è No valid buffered data or duration not available");
          console.log("üîç Buffered length:", currentBuffered.length);
          console.log("üîç Duration:", videoElement.duration);
          console.log("üîç Duration isNaN:", isNaN(videoElement.duration));

          // Fallback: Check readyState for immediate availability
          if (videoElement.readyState >= 3) {
            // HAVE_FUTURE_DATA or higher
            console.log("=== READYSTATE FALLBACK TRIGGERED ===");
            console.log("üöÄ ReadyState indicates sufficient data loaded");

            isCompleted = true;
            clearInterval(progressTracker);

            setTimeout(async () => {
              try {
                setDownloadProgress(100);
                videoElement.playbackRate = playbackRate;
                await videoElement.play();
                setLoaded(true);
                setPlaying(true);
                console.log("‚úÖ Video started via readyState fallback!");
              } catch (playError) {
                console.error("‚ùå Playback error in fallback:", playError);
                setLoaded(true);
                setError("Auto-play prevented");
              }
            }, 100);
            return;
          }
        }

        // Safety timeout
        if (progressUpdateCount >= 300) {
          // 15 seconds max
          console.warn("=== PROGRESS TRACKING TIMEOUT ===");
          console.warn("‚è∞ Progress tracking timeout after 15 seconds!");

          isCompleted = true;
          clearInterval(progressTracker);
          setDownloadProgress(100);
          setLoaded(true);
          setError("Loading timeout - proceeding anyway");
          return;
        }
      } catch (progressError) {
        console.error(
          "‚ùå Error in progress tracking iteration:",
          progressError
        );
        if (progressError instanceof Error) {
          console.error("‚ùå Error stack:", progressError.stack);
        }
      }
    }, 50); // Check every 50ms for smooth updates

    console.log(
      "‚è≥ Progress tracker started successfully, waiting for completion..."
    );
  } catch (error) {
    console.error("‚ùå CRITICAL ERROR in handleVideoLoading:", error);
    if (error instanceof Error) {
      console.error("‚ùå Error stack:", error.stack);
    }

    // Emergency fallback
    try {
      const emergencyStore = useVideoStore.getState();
      emergencyStore.setDownloadProgress(100);
      emergencyStore.setLoaded(true);
      emergencyStore.setError("Loading error - emergency fallback");
      console.log("üö® Emergency fallback executed");
    } catch (emergencyError) {
      console.error("‚ùå Emergency fallback also failed:", emergencyError);
    }

    throw error;
  }
};

/**
 * Hook to get video loading function with store integration
 */
export const useVideoLoader = () => {
  return {
    loadVideo: handleVideoLoading,
    resetVideo: () => {
      const { resetVideo } = useVideoStore.getState();
      resetVideo();
    },
  };
};

/**
 * Utility to check if video is cached/already downloaded
 */
export const isVideoCached = async (videoUrl: string): Promise<boolean> => {
  try {
    const response = await fetch(videoUrl, { method: "HEAD" });
    return response.status === 200;
  } catch {
    return false;
  }
};
